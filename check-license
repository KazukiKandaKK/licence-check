#!/usr/bin/env python3
"""
License Check CLI Tool
Scans current directory recursively for potential license and copyright issues.
"""

import os
import sys
import pathlib
import re
import argparse
from collections import defaultdict
from datetime import datetime
import hashlib

# Tool version
__version__ = "0.1.0"

# Color codes for terminal output
class Colors:
    RED = '\033[91m'
    YELLOW = '\033[93m'
    GREEN = '\033[92m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'

def colorize(text, color):
    """Add color to text if terminal supports it"""
    if sys.stdout.isatty():
        return f"{color}{text}{Colors.END}"
    return text


def extract_code_content(content):
    """Extract actual code from content that may contain markdown blocks"""
    # Look for code blocks
    code_block_pattern = r'```(?:python|go|typescript|js|ts|java|cpp|c)?\n(.*?)```'
    matches = re.findall(code_block_pattern, content, re.DOTALL | re.IGNORECASE)
    
    if matches:
        return matches[0].strip()
    return content.strip()

def analyze_file_content(file_path):
    """Analyze file for license-related issues"""
    issues = []
    
    try:
        # Skip binary files and common non-code files
        if not is_text_file(file_path):
            return issues
            
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        lines = content.split('\n')
        
        # Critical license detection patterns - focus on actual license text
        license_patterns = [
            # Explicit license headers
            (r'copyright\s+\(c\)\s+\d{4}', 'è‘—ä½œæ¨©è¡¨ç¤º (å…·ä½“çš„å¹´æ•°ä»˜ã)', 'CRITICAL'),
            (r'copyright.*\d{4}.*all rights reserved', 'å®Œå…¨ãªè‘—ä½œæ¨©å®£è¨€', 'CRITICAL'),
            (r'permission is hereby granted.*free of charge', 'MIT/BSDãƒ©ã‚¤ã‚»ãƒ³ã‚¹å…¨æ–‡', 'CRITICAL'),
            (r'licensed under the apache license.*version 2\.0', 'Apache License 2.0 å…¨æ–‡', 'CRITICAL'),
            (r'gnu general public license.*version [23]', 'GPL v2/v3 ãƒ©ã‚¤ã‚»ãƒ³ã‚¹å…¨æ–‡', 'CRITICAL'),
            (r'mozilla public license.*version 2\.0', 'MPL 2.0 ãƒ©ã‚¤ã‚»ãƒ³ã‚¹å…¨æ–‡', 'CRITICAL'),
            (r'redistribution and use.*permitted provided', 'BSDãƒ©ã‚¤ã‚»ãƒ³ã‚¹æ¡é …', 'CRITICAL'),
            (r'spdx-license-identifier:\s*[a-z0-9\-\.]+', 'SPDXãƒ©ã‚¤ã‚»ãƒ³ã‚¹è­˜åˆ¥å­', 'CRITICAL'),
            
            # Shorter but still significant license indicators
            (r'all rights reserved', 'æ¨©åˆ©ç•™ä¿æ¡é …', 'HIGH'),
            (r'copyright.*\d{4}', 'è‘—ä½œæ¨©è¡¨ç¤º', 'HIGH'),
            (r'\(c\)\s*\d{4}', 'è‘—ä½œæ¨©è¨˜å·', 'HIGH'),
            (r'@copyright\s+\d{4}', 'è‘—ä½œæ¨©ã‚¢ãƒŽãƒ†ãƒ¼ã‚·ãƒ§ãƒ³', 'HIGH'),
            (r'@author.*\d{4}', 'ä½œè€…ãƒ»å¹´åº¦è¡¨ç¤º', 'MEDIUM'),
            
            # License file headers
            (r'this file is part of.*project', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå¸°å±žè¡¨ç¤º', 'HIGH'),
            (r'license.*see.*file', 'ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«å‚ç…§', 'MEDIUM'),
        ]
        
        all_patterns = license_patterns
        
        for line_num, line in enumerate(lines, 1):
            line_lower = line.lower().strip()
            
            # Skip lines that are clearly pattern definitions or tool-related comments
            if (re.search(r'[\'\"]\s*[,)]|license_patterns', line_lower) or
                line_lower.strip().startswith('#') or
                line_lower.strip().startswith('//') or
                line_lower.strip().startswith('*') or
                'license check tool' in line_lower):
                continue
            
            for pattern, description, severity in all_patterns:
                if re.search(pattern, line_lower):
                    issues.append({
                        'line': line_num,
                        'content': line.strip()[:100] + ('...' if len(line.strip()) > 100 else ''),
                        'issue': description,
                        'severity': severity,
                        'pattern': pattern
                    })
        
        
    
    except Exception as e:
        issues.append({
            'line': 'N/A',
            'content': f'ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {str(e)[:50]}',
            'issue': 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼',
            'severity': 'LOW',
            'pattern': 'error'
        })
    
    return issues

def is_text_file(file_path):
    """Check if file is likely a text file"""
    try:
        # Check file extension
        text_extensions = {
            '.py', '.js', '.ts', '.java', '.cpp', '.c', '.h', '.hpp',
            '.go', '.rs', '.rb', '.php', '.cs', '.swift', '.kt',
            '.html', '.css', '.scss', '.less', '.xml', '.json',
            '.yml', '.yaml', '.toml', '.ini', '.cfg', '.conf',
            '.txt', '.md', '.rst', '.tex', '.sql', '.sh', '.bash',
            '.ps1', '.bat', '.cmd', '.R', '.r', '.m', '.scala',
            '.clj', '.cljs', '.hs', '.elm', '.dart', '.vue',
            '.jsx', '.tsx', '.svelte'
        }
        
        if file_path.suffix.lower() in text_extensions:
            return True
        
        # Try to read first few bytes
        with open(file_path, 'rb') as f:
            chunk = f.read(1024)
            if b'\x00' in chunk:  # Binary file indicator
                return False
            
        # Additional check for shebang
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            first_line = f.readline()
            if first_line.startswith('#!'):
                return True
                
        return True
    except:
        return False

def scan_directory(directory, ignore_patterns=None):
    """Recursively scan directory for files"""
    if ignore_patterns is None:
        ignore_patterns = {
            # Version control
            '.git', '.svn', '.hg', '.bzr',
            # Dependencies
            'node_modules', '__pycache__', '.venv', 'venv', 'env',
            'vendor', 'target', 'build', 'dist', 'out',
            # IDE files
            '.vscode', '.idea', '.eclipse',
            # OS files
            '.DS_Store', 'Thumbs.db',
            # Archives and binaries
            '.zip', '.tar', '.gz', '.rar', '.7z', '.exe', '.dll', '.so',
            # Images and media
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.ico',
            '.mp3', '.mp4', '.avi', '.mov', '.wav', '.pdf'
        }
    
    files_found = []
    issues_found = defaultdict(list)
    
    try:
        for root, dirs, files in os.walk(directory):
            # Filter out ignored directories
            dirs[:] = [d for d in dirs if d not in ignore_patterns and not d.startswith('.')]
            
            for file in files:
                file_path = pathlib.Path(root) / file
                
                # Skip ignored files
                if (file.startswith('.') or 
                    file_path.suffix in ignore_patterns or
                    any(pattern in str(file_path) for pattern in ignore_patterns)):
                    continue
                
                files_found.append(file_path)
                
                # Analyze file
                file_issues = analyze_file_content(file_path)
                if file_issues:
                    issues_found[str(file_path)] = file_issues
    
    except PermissionError as e:
        print(colorize(f"ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚¨ãƒ©ãƒ¼: {e}", Colors.YELLOW))
    except Exception as e:
        print(colorize(f"ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: {e}", Colors.RED))
    
    return files_found, issues_found

def print_summary(files_found, issues_found, args):
    """Print scan results summary"""
    total_files = len(files_found)
    files_with_issues = len(issues_found)
    total_issues = sum(len(issues) for issues in issues_found.values())
    
    # Count by severity
    severity_counts = defaultdict(int)
    for issues in issues_found.values():
        for issue in issues:
            severity_counts[issue['severity']] += 1
    
    print("\n" + "="*60)
    print(colorize("ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯çµæžœ", Colors.BOLD + Colors.CYAN))
    print("="*60)
    
    print(f"ðŸ“ ã‚¹ã‚­ãƒ£ãƒ³ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {colorize(os.getcwd(), Colors.BLUE)}")
    print(f"ðŸ“„ è§£æžãƒ•ã‚¡ã‚¤ãƒ«æ•°: {colorize(str(total_files), Colors.WHITE)}")
    print(f"âš ï¸  å•é¡Œã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«æ•°: {colorize(str(files_with_issues), Colors.YELLOW if files_with_issues > 0 else Colors.GREEN)}")
    print(f"ðŸ” ç™ºè¦‹ã•ã‚ŒãŸå•é¡Œæ•°: {colorize(str(total_issues), Colors.RED if total_issues > 0 else Colors.GREEN)}")
    
    if severity_counts:
        print(f"\nðŸ“Š é‡è¦åº¦åˆ¥å•é¡Œæ•°:")
        severity_labels = {
            'CRITICAL': 'é‡è¦',
            'HIGH': 'é«˜',
            'MEDIUM': 'ä¸­',
            'LOW': 'ä½Ž'
        }
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            count = severity_counts.get(severity, 0)
            if count > 0:
                color = {
                    'CRITICAL': Colors.RED + Colors.BOLD,
                    'HIGH': Colors.RED,
                    'MEDIUM': Colors.YELLOW,
                    'LOW': Colors.WHITE
                }.get(severity, Colors.WHITE)
                print(f"   {colorize(severity_labels[severity], color)}: {count}ä»¶")
    
    if not args.summary_only and issues_found:
        print(f"\n{colorize('è©³ç´°ãªå•é¡Œä¸€è¦§', Colors.BOLD + Colors.UNDERLINE)}")
        print("-" * 60)
        
        # Sort files by severity of issues
        sorted_files = sorted(issues_found.items(), 
                            key=lambda x: max(issue.get('severity', 'LOW') == 'CRITICAL' for issue in x[1]), 
                            reverse=True)
        
        for file_path, issues in sorted_files:
            rel_path = os.path.relpath(file_path)
            print(f"\nðŸ“„ {colorize(rel_path, Colors.BLUE + Colors.BOLD)}")
            
            # Group issues by severity
            issues_by_severity = defaultdict(list)
            for issue in issues:
                issues_by_severity[issue['severity']].append(issue)
            
            for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
                if severity in issues_by_severity:
                    color = {
                        'CRITICAL': Colors.RED + Colors.BOLD,
                        'HIGH': Colors.RED,
                        'MEDIUM': Colors.YELLOW,
                        'LOW': Colors.WHITE
                    }.get(severity, Colors.WHITE)
                    
                    for issue in issues_by_severity[severity]:
                        line_info = f"{issue['line']}è¡Œç›®" if issue['line'] != 'N/A' else "ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“"
                        print(f"   {colorize('â—', color)} {colorize(issue['issue'], color)} ({line_info})")
                        if args.verbose:
                            print(f"     å†…å®¹: {colorize(issue['content'], Colors.WHITE)}")
    
    # Recommendations
    if total_issues > 0:
        print(f"\n{colorize('æŽ¨å¥¨å¯¾å¿œ', Colors.BOLD + Colors.YELLOW)}")
        print("-" * 60)
        
        has_critical = severity_counts.get('CRITICAL', 0) > 0
        has_high = severity_counts.get('HIGH', 0) > 0
        
        if has_critical:
            print("ðŸš¨ é‡è¦ãªå•é¡ŒãŒç™ºè¦‹ã•ã‚Œã¾ã—ãŸ - è‡³æ€¥ç¢ºèªã—ã¦ãã ã•ã„ï¼")
            print("   â€¢ å®Ÿéš›ã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹é•åãŒãªã„ã‹ç¢ºèª")
            print("   â€¢ ã‚³ãƒ¼ãƒ‰ã®æ‰€æœ‰æ¨©ã¨è¨±å¯ã‚’æ¤œè¨¼")
        
        if has_high:
            print("âš ï¸  é«˜å„ªå…ˆåº¦ã®å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ:")
            print("   â€¢ è‘—ä½œæ¨©è¡¨ç¤ºã¨å¸°å±žã‚’ç¢ºèª")
            print("   â€¢ é©åˆ‡ãªãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª")
        
        print("ðŸ’¡ ä¸€èˆ¬çš„ãªæŽ¨å¥¨äº‹é …:")
        print("   â€¢ ãƒ•ã‚¡ã‚¤ãƒ«ã«é©åˆ‡ãªãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ ")
        print("   â€¢ ã‚³ãƒ¼ãƒ‰ã®å‡ºå…¸ã¨å¸°å±žã‚’æ–‡æ›¸åŒ–")
        print("   â€¢ SPDXãƒ©ã‚¤ã‚»ãƒ³ã‚¹è­˜åˆ¥å­ã‚’ä½¿ç”¨")
        print("   â€¢ CI/CDã§ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã‚¹ã‚­ãƒ£ãƒ³ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ã‚’æ¤œè¨Ž")
    else:
        print(f"\n{colorize('âœ… ãƒ©ã‚¤ã‚»ãƒ³ã‚¹å•é¡Œã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸï¼', Colors.GREEN + Colors.BOLD)}")
        print("ã‚³ãƒ¼ãƒ‰ã¯ãƒ©ã‚¤ã‚»ãƒ³ã‚¹é–¢é€£ã®æ‡¸å¿µäº‹é …ãŒãªã„ã‚ˆã†ã§ã™ã€‚")

def main():
    parser = argparse.ArgumentParser(
        description="ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¨è‘—ä½œæ¨©å•é¡Œã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¾ã™",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  check-license                    # ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¹ã‚­ãƒ£ãƒ³
  check-license --summary-only     # ã‚µãƒžãƒªãƒ¼ã®ã¿è¡¨ç¤º
  check-license --verbose          # è©³ç´°ãªå•é¡Œå†…å®¹ã‚’è¡¨ç¤º
  check-license --ignore node_modules,dist  # ç‰¹å®šã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç„¡è¦–
        """
    )
    
    parser.add_argument('--summary-only', '-s', action='store_true',
                        help='ã‚µãƒžãƒªãƒ¼ã®ã¿è¡¨ç¤ºï¼ˆè©³ç´°ãªå•é¡Œã¯è¡¨ç¤ºã—ãªã„ï¼‰')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='è©³ç´°ãªå•é¡Œå†…å®¹ã‚’è¡¨ç¤º')
    parser.add_argument('--ignore', '-i', type=str,
                        help='ç„¡è¦–ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª/ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚«ãƒ³ãƒžåŒºåˆ‡ã‚Šï¼‰')
    parser.add_argument('--output', '-o', type=str,
                        help='çµæžœã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ï¼ˆCSVå½¢å¼ï¼‰')
    parser.add_argument('--version', action='version',
                        version=f'%(prog)s {__version__}',
                        help='ãƒ„ãƒ¼ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¡¨ç¤ºã—ã¦çµ‚äº†')
    
    args = parser.parse_args()
    
    # Parse ignore patterns
    ignore_patterns = None
    if args.ignore:
        ignore_patterns = set(args.ignore.split(','))
    
    print(colorize("ðŸ” ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«", Colors.BOLD + Colors.CYAN))
    print(f"ã‚¹ã‚­ãƒ£ãƒ³ä¸­: {colorize(os.getcwd(), Colors.BLUE)}")
    print("ãŠå¾…ã¡ãã ã•ã„...\n")
    
    # Scan directory
    files_found, issues_found = scan_directory('.', ignore_patterns)
    
    # Print results
    print_summary(files_found, issues_found, args)
    
    # Save to file if requested
    if args.output:
        save_to_csv(files_found, issues_found, args.output)
        print(f"\nðŸ’¾ çµæžœã‚’ä¿å­˜ã—ã¾ã—ãŸ: {colorize(args.output, Colors.GREEN)}")
    
    # Exit with appropriate code
    total_issues = sum(len(issues) for issues in issues_found.values())
    critical_issues = sum(1 for issues in issues_found.values() 
                         for issue in issues if issue['severity'] == 'CRITICAL')
    
    if critical_issues > 0:
        sys.exit(2)  # Critical issues found
    elif total_issues > 0:
        sys.exit(1)  # Non-critical issues found
    else:
        sys.exit(0)  # No issues

def save_to_csv(files_found, issues_found, output_file):
    """Save results to CSV file"""
    import csv
    
    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(['file_path', 'line', 'issue_type', 'severity', 'content', 'pattern'])
        
        for file_path, issues in issues_found.items():
            for issue in issues:
                writer.writerow([
                    file_path,
                    issue['line'],
                    issue['issue'],
                    issue['severity'],
                    issue['content'],
                    issue['pattern']
                ])

if __name__ == "__main__":
    main()